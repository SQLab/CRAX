#ifndef S2E_PLUGINS_EXPLOIT_H
#define S2E_PLUGINS_EXPLOIT_H

#include <s2e/Plugin.h>
#include <s2e/Plugins/CorePlugin.h>
#include <s2e/S2EExecutionState.h>

using namespace std;

namespace s2e {
namespace plugins {

class ExploitGenerator : public Plugin
{
    S2E_PLUGIN
public:
    ExploitGenerator(S2E *s2e): Plugin(s2e) {}

    void initialize();

private:
    string m_shellCode;

    klee::ref<klee::Expr> m_eipValue;

    typedef std::pair<std::string, std::vector<unsigned char> > VarValuePair;
    typedef std::vector<VarValuePair> ConcreteInputs;

    void onEipCorrupt(S2EExecutionState *state,
                      klee::ref<klee::Expr> eipValue);

    void findTaintedObjects(S2EExecutionState *state,
                            uint64_t startAddress,
                            uint64_t endAddress,
                            set<uint64_t> *taintedAddressSet);

    void findSymbolicArray(S2EExecutionState *state,
                           set<uint64_t> const& taintedAddressSet,
                           map<uint64_t, uint64_t> *symbolicArrayMap);

    void pruneInputConstraints(S2EExecutionState *state,
                               klee::ExecutionState *exploitState);

    klee::ref<klee::Expr> generateConstraints(S2EExecutionState *state,
                                              uint64_t startAddress,
                                              uint64_t nopAddress,
                                              uint64_t shellCodeAddress);

    void generateExploit(S2EExecutionState *state,
                         uint64_t startAddress, uint64_t width);

    string str2byte(string str);
};

} // namespace plugins
} // namespace s2e

#endif
